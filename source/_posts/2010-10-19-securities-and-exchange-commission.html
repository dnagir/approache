---
layout: post
title: Securities and Exchange Commission – comment on comment
date: 2010-10-19 10:30:00.000000000 +11:00
comments: true
categories:
- ruby
- java
- development
- devtools
- standards
- security
---

<div class='post'>
<p>I have been going through the <a href="http://www.sec.gov/comments/s7-08-10/s70810-89.pdf">comments submitted</a> to the US Securities and Exchange Commission.</p>  <p>I feel like I have to add my 2 cents on it. My first <em>impression </em>is that the analysis was not performed in full and the authors are being very affiliated with a company (which seems to be Microsoft).</p>  <p>One and most important issue with this document is that authors do not seem to fully understand the dynamic languages and they have not even taken into account (possibly) the most suited language for the task – <a href="http://www.ruby-lang.org/">Ruby</a>. Of course I may be wrong.</p>  <p>I have to say that I have nothing against authors or anything like that.</p>  <p>My point is that <em>I believe</em> that the analysis could have been performed more deeply with close interaction with professionals of the particular languages.</p>  <p>So now, I would like to comment on the submission:</p>  <blockquote>   <p>Safe execution of code written by one party on a machine owned by a different party was not a strong concern in the design of Python. It was a strong concern in the design of other systems, including Java and the .Net framework</p> </blockquote>  <p>This is neither sufficient nor necessary to achieve the security. The security is the effort of the developers, IT administrators and the people working with the system. Even when using an interpreted language it can be executed inside a virtual machine (be it JVM, .NET, SmallTalk etc) providing that sandbox mentioned above. Most common examples are – Jython, IronPython, JRuby, IronRuby etc. This cannot be served as a decision point.</p>  <blockquote>   <p>A domain-specific language would support writing waterfall programs that are shorter and easier to read, and should help ensure consistency between the program and the narrative description.</p> </blockquote>  <p>This is exactly what Ruby, Python and other dynamic languages are good at. And this is exactly what C#, Java and other static typed languages are bad at. Not sure why having it as a crucial requirements the wrong tool for the job is advocated.</p>  <blockquote>   <p><strong>Efficiency</strong>. … Java, C#, and F# are designed to be executed efficiently, Python and Perl implementations are significantly less efficient.</p> </blockquote>  <p>This is true in many cases. But having the requirements in mind, the language inefficiency can be compensated with additional hardware. Its cost is significantly less than the cost of development time using strongly/statically typed languages.    <br />If additional performance needed – then the just-in-time compiler can be used instead of interpretation (this includes Rubinius, IronRuby, JRuby, MacRuby etc)</p>  <blockquote>   <p><strong>Typing</strong>. Statically typed languages are generally considered to produce more reliable and easier to maintain code, while dynamically typed languages are generally considered to produce more flexible code and to be better suited for prototyping. Java, C#, F# are statically typed; Python and Perl are dynamically typed.</p> </blockquote>  <p>This can phrase exactly the other way around and is neither sufficient nor necessary to achieve supportability.</p>  <p>The wording is rather weird here:&#160; “<em>…languages are .. considered to produce more reliable and easier to maintain code</em>”. The languages do NOT produce code. It is a developer who does it.</p>  <blockquote>   <p><strong>Security</strong>. Some programming languages have been designed with security in mind, and some of their implementations include “sandboxes” that can securely execute untrusted code. Java, C#, and F# are such languages; Python and Perl are not.</p> </blockquote>  <p>As I mentioned above it cannot be the the deciding point because most of the dynamically typed languages can be easily run inside that sandbox using either a JVM, JIT or just a virtual machine; also sandboxing in the sense above does not eliminate the security issues. And we have a <a href="http://weblogs.asp.net/scottgu/archive/2010/09/18/important-asp-net-security-vulnerability.aspx">fairly recent example</a> of that.</p>  <blockquote>   <p><strong>Domain-specific languages</strong>. Any programming language can serve as a basis for a domain-specific language by augmenting it with suitable libraries. Experience seems to show that higher-order programming languages such as F# provide a particularly good basis for domain-specific languages. There are financial domain-specific languages available in F#.</p> </blockquote>  <p>I don’t understand why F# is the only recommendation here. Ruby is one of the greatest languages to produce DSLs. Clojure may also be considered. For that matter Martin Fowler’s Domain Specific Languages book can be used as the starting point.</p>  <p>&#160;</p>  <p>I do advocate Ruby language here and believe it can be used with a great success. Only one huge disadvantage of it is the absence of a formal specification (which in my opinion is the advantage as it allows better evolution of the language).</p>  <p>And of course there are many factors that have to be taken into account that may roll Ruby out, but it must be considered at least.</p>  <p>Additionally inviting professionals from Ruby, Python, Perl communities to suggest on the subject will provide much more information and will allow making an informative decision.</p>  </div>
